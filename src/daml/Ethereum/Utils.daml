daml 1.2

module Ethereum.Utils where

import DA.Text


gasBaseFee : Int = 21000  -- https://github.com/ethereum/wiki/wiki/Design-Rationale


data EtherUnits = Wei    Decimal
                | Kwei   Decimal
                | Mwei   Decimal
                | Gwei   Decimal
                | Szabo  Decimal
                | Finney Decimal
                | Ether  Decimal
                | Kether Decimal
                | Mether Decimal
                | Gether Decimal
  deriving (Eq, Show)


checkDecimals : Text -> Bool
checkDecimals weiText =
  let decimalsText = DA.Text.takeWhileEnd (\c -> c /= ".") weiText
      optDecimals = parseDecimal decimalsText
  in case optDecimals of
    Some decimal -> decimal == 0.0
    None -> False


validEtherUnits : EtherUnits -> Bool
validEtherUnits units = case units of
  Wei    v -> v >= 0.0 && (checkDecimals $ show v)
  Kwei   v -> v >= 0.0 && (checkDecimals $ show $ v * 1e3)
  Mwei   v -> v >= 0.0 && (checkDecimals $ show $ v * 1e6)
  Gwei   v -> v >= 0.0 && (checkDecimals $ show $ v * 1e9)
  Szabo  v -> v >= 0.0 && (checkDecimals $ show $ v * 1e12)
  Finney v -> v >= 0.0 && (checkDecimals $ show $ v * 1e15)
  Ether  v -> v >= 0.0 && (checkDecimals $ show $ v * 1e18)
  Kether v -> v >= 0.0 && (checkDecimals $ show $ v * 1e21)
  Mether v -> v >= 0.0 && (checkDecimals $ show $ v * 1e24)
  Gether v -> v >= 0.0 && (checkDecimals $ show $ v * 1e27)


zeroWei : EtherUnits = Wei 0.0


toWeiText : EtherUnits -> Text
toWeiText etherUnits =
  let wei = case etherUnits of
        Wei    v -> v
        Kwei   v -> v * 1e3
        Mwei   v -> v * 1e6
        Gwei   v -> v * 1e9
        Szabo  v -> v * 1e12
        Finney v -> v * 1e15
        Ether  v -> v * 1e18
        Kether v -> v * 1e21
        Mether v -> v * 1e24
        Gether v -> v * 1e27
  in DA.Text.takeWhile (\c -> c /= ".") $ show wei


data ABIType = ABIBool
             | ABIUint
             | ABIInt
             | ABIBytes
             | ABIString
             | ABIAddress
  deriving (Eq, Show)


data ABIValue = ABIValue with
                  abiType  : ABIType
                  abiValue : Text
              | ABIList [ABIValue]
  deriving (Eq, Show)


data SendStatus = New
                | Pending
                | Sent with
                    when   : Time
                    from   : Text
                    txHash : Optional Text
                | FailedToSend with
                    reason : Text
  deriving (Eq, Show)


checkNesting : [ABIValue] -> Int -> Int -> Bool
checkNesting _ curr limit | curr == limit = False
checkNesting [] _ _ = True
checkNesting (x::xs) i limit =
  case x of
    ABIList y -> checkNesting y (i+1) limit && checkNesting xs i limit
    _  -> checkNesting xs i limit
